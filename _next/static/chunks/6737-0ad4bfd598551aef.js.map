{"version":3,"file":"static/chunks/6737-0ad4bfd598551aef.js","mappings":"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","sources":["webpack://_N_E/../node_modules/@react-dnd/invariant/dist/esm/index.mjs","webpack://_N_E/../node_modules/@react-dnd/shallowequal/dist/esm/index.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/core/DndContext.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useMonitorOutput.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useCollector.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useCollectedProps.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useDragDropManager.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useDrop/DropTargetImpl.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useDrop/useRegisteredDropTarget.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useDrop/useDropTarget.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useDrop/useAccept.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/internals/DropTargetMonitorImpl.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/internals/TargetConnector.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useDrop/connectors.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useDrop/useDrop.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useDrop/useDropTargetMonitor.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useDrop/useDropTargetConnector.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useIsomorphicLayoutEffect.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/hooks/useOptionalFactory.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/internals/isRef.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/internals/registration.mjs","webpack://_N_E/../node_modules/react-dnd/dist/esm/internals/wrapConnectorHooks.mjs"],"sourcesContent":["/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */ export function invariant(condition, format, ...args) {\n    if (isProduction()) {\n        if (format === undefined) {\n            throw new Error('invariant requires an error message argument');\n        }\n    }\n    if (!condition) {\n        let error;\n        if (format === undefined) {\n            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n        } else {\n            let argIndex = 0;\n            error = new Error(format.replace(/%s/g, function() {\n                return args[argIndex++];\n            }));\n            error.name = 'Invariant Violation';\n        }\n        error.framesToPop = 1 // we don't care about invariant's own frame\n        ;\n        throw error;\n    }\n}\nfunction isProduction() {\n    return typeof process !== 'undefined' && process.env['NODE_ENV'] === 'production';\n}\n\n//# sourceMappingURL=index.mjs.map","export function shallowEqual(objA, objB, compare, compareContext) {\n    let compareResult = compare ? compare.call(compareContext, objA, objB) : void 0;\n    if (compareResult !== void 0) {\n        return !!compareResult;\n    }\n    if (objA === objB) {\n        return true;\n    }\n    if (typeof objA !== 'object' || !objA || typeof objB !== 'object' || !objB) {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n    // Test for A's keys different from B.\n    for(let idx = 0; idx < keysA.length; idx++){\n        const key = keysA[idx];\n        if (!bHasOwnProperty(key)) {\n            return false;\n        }\n        const valueA = objA[key];\n        const valueB = objB[key];\n        compareResult = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n        if (compareResult === false || compareResult === void 0 && valueA !== valueB) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//# sourceMappingURL=index.mjs.map","import { createContext } from 'react';\n/**\n * Create the React Context\n */ export const DndContext = createContext({\n    dragDropManager: undefined\n});\n\n//# sourceMappingURL=DndContext.mjs.map","import { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect.mjs';\nimport { useCollector } from './useCollector.mjs';\nexport function useMonitorOutput(monitor, collect, onCollect) {\n    const [collected, updateCollected] = useCollector(monitor, collect, onCollect);\n    useIsomorphicLayoutEffect(function subscribeToMonitorStateChange() {\n        const handlerId = monitor.getHandlerId();\n        if (handlerId == null) {\n            return;\n        }\n        return monitor.subscribeToStateChange(updateCollected, {\n            handlerIds: [\n                handlerId\n            ]\n        });\n    }, [\n        monitor,\n        updateCollected\n    ]);\n    return collected;\n}\n\n//# sourceMappingURL=useMonitorOutput.mjs.map","import equal from 'fast-deep-equal';\nimport { useState, useCallback } from 'react';\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect.mjs';\n/**\n *\n * @param monitor The monitor to collect state from\n * @param collect The collecting function\n * @param onUpdate A method to invoke when updates occur\n */ export function useCollector(monitor, collect, onUpdate) {\n    const [collected, setCollected] = useState(()=>collect(monitor)\n    );\n    const updateCollected = useCallback(()=>{\n        const nextValue = collect(monitor);\n        // This needs to be a deep-equality check because some monitor-collected values\n        // include XYCoord objects that may be equivalent, but do not have instance equality.\n        if (!equal(collected, nextValue)) {\n            setCollected(nextValue);\n            if (onUpdate) {\n                onUpdate();\n            }\n        }\n    }, [\n        collected,\n        monitor,\n        onUpdate\n    ]);\n    // update the collected properties after react renders.\n    // Note that the \"Dustbin Stress Test\" fails if this is not\n    // done when the component updates\n    useIsomorphicLayoutEffect(updateCollected);\n    return [\n        collected,\n        updateCollected\n    ];\n}\n\n//# sourceMappingURL=useCollector.mjs.map","import { useMonitorOutput } from './useMonitorOutput.mjs';\nexport function useCollectedProps(collector, monitor, connector) {\n    return useMonitorOutput(monitor, collector || (()=>({})\n    ), ()=>connector.reconnect()\n    );\n}\n\n//# sourceMappingURL=useCollectedProps.mjs.map","import { useContext } from 'react';\nimport { invariant } from '@react-dnd/invariant';\nimport { DndContext } from '../core/index.mjs';\n/**\n * A hook to retrieve the DragDropManager from Context\n */ export function useDragDropManager() {\n    const { dragDropManager  } = useContext(DndContext);\n    invariant(dragDropManager != null, 'Expected drag drop context');\n    return dragDropManager;\n}\n\n//# sourceMappingURL=useDragDropManager.mjs.map","export class DropTargetImpl {\n    canDrop() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;\n    }\n    hover() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (spec.hover) {\n            spec.hover(monitor.getItem(), monitor);\n        }\n    }\n    drop() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (spec.drop) {\n            return spec.drop(monitor.getItem(), monitor);\n        }\n        return;\n    }\n    constructor(spec, monitor){\n        this.spec = spec;\n        this.monitor = monitor;\n    }\n}\n\n//# sourceMappingURL=DropTargetImpl.mjs.map","import { registerTarget } from '../../internals/index.mjs';\nimport { useDragDropManager } from '../useDragDropManager.mjs';\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect.mjs';\nimport { useAccept } from './useAccept.mjs';\nimport { useDropTarget } from './useDropTarget.mjs';\nexport function useRegisteredDropTarget(spec, monitor, connector) {\n    const manager = useDragDropManager();\n    const dropTarget = useDropTarget(spec, monitor);\n    const accept = useAccept(spec);\n    useIsomorphicLayoutEffect(function registerDropTarget() {\n        const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);\n        monitor.receiveHandlerId(handlerId);\n        connector.receiveHandlerId(handlerId);\n        return unregister;\n    }, [\n        manager,\n        monitor,\n        dropTarget,\n        connector,\n        accept.map((a)=>a.toString()\n        ).join('|'), \n    ]);\n}\n\n//# sourceMappingURL=useRegisteredDropTarget.mjs.map","import { useEffect, useMemo } from 'react';\nimport { DropTargetImpl } from './DropTargetImpl.mjs';\nexport function useDropTarget(spec, monitor) {\n    const dropTarget = useMemo(()=>new DropTargetImpl(spec, monitor)\n    , [\n        monitor\n    ]);\n    useEffect(()=>{\n        dropTarget.spec = spec;\n    }, [\n        spec\n    ]);\n    return dropTarget;\n}\n\n//# sourceMappingURL=useDropTarget.mjs.map","import { invariant } from '@react-dnd/invariant';\nimport { useMemo } from 'react';\n/**\n * Internal utility hook to get an array-version of spec.accept.\n * The main utility here is that we aren't creating a new array on every render if a non-array spec.accept is passed in.\n * @param spec\n */ export function useAccept(spec) {\n    const { accept  } = spec;\n    return useMemo(()=>{\n        invariant(spec.accept != null, 'accept must be defined');\n        return Array.isArray(accept) ? accept : [\n            accept\n        ];\n    }, [\n        accept\n    ]);\n}\n\n//# sourceMappingURL=useAccept.mjs.map","import { invariant } from '@react-dnd/invariant';\nlet isCallingCanDrop = false;\nexport class DropTargetMonitorImpl {\n    receiveHandlerId(targetId) {\n        this.targetId = targetId;\n    }\n    getHandlerId() {\n        return this.targetId;\n    }\n    subscribeToStateChange(listener, options) {\n        return this.internalMonitor.subscribeToStateChange(listener, options);\n    }\n    canDrop() {\n        // Cut out early if the target id has not been set. This should prevent errors\n        // where the user has an older version of dnd-core like in\n        // https://github.com/react-dnd/react-dnd/issues/1310\n        if (!this.targetId) {\n            return false;\n        }\n        invariant(!isCallingCanDrop, 'You may not call monitor.canDrop() inside your canDrop() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor');\n        try {\n            isCallingCanDrop = true;\n            return this.internalMonitor.canDropOnTarget(this.targetId);\n        } finally{\n            isCallingCanDrop = false;\n        }\n    }\n    isOver(options) {\n        if (!this.targetId) {\n            return false;\n        }\n        return this.internalMonitor.isOverTarget(this.targetId, options);\n    }\n    getItemType() {\n        return this.internalMonitor.getItemType();\n    }\n    getItem() {\n        return this.internalMonitor.getItem();\n    }\n    getDropResult() {\n        return this.internalMonitor.getDropResult();\n    }\n    didDrop() {\n        return this.internalMonitor.didDrop();\n    }\n    getInitialClientOffset() {\n        return this.internalMonitor.getInitialClientOffset();\n    }\n    getInitialSourceClientOffset() {\n        return this.internalMonitor.getInitialSourceClientOffset();\n    }\n    getSourceClientOffset() {\n        return this.internalMonitor.getSourceClientOffset();\n    }\n    getClientOffset() {\n        return this.internalMonitor.getClientOffset();\n    }\n    getDifferenceFromInitialOffset() {\n        return this.internalMonitor.getDifferenceFromInitialOffset();\n    }\n    constructor(manager){\n        this.targetId = null;\n        this.internalMonitor = manager.getMonitor();\n    }\n}\n\n//# sourceMappingURL=DropTargetMonitorImpl.mjs.map","import { shallowEqual } from '@react-dnd/shallowequal';\nimport { wrapConnectorHooks } from './wrapConnectorHooks.mjs';\nimport { isRef } from './isRef.mjs';\nexport class TargetConnector {\n    get connectTarget() {\n        return this.dropTarget;\n    }\n    reconnect() {\n        // if nothing has changed then don't resubscribe\n        const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();\n        if (didChange) {\n            this.disconnectDropTarget();\n        }\n        const dropTarget = this.dropTarget;\n        if (!this.handlerId) {\n            return;\n        }\n        if (!dropTarget) {\n            this.lastConnectedDropTarget = dropTarget;\n            return;\n        }\n        if (didChange) {\n            this.lastConnectedHandlerId = this.handlerId;\n            this.lastConnectedDropTarget = dropTarget;\n            this.lastConnectedDropTargetOptions = this.dropTargetOptions;\n            this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);\n        }\n    }\n    receiveHandlerId(newHandlerId) {\n        if (newHandlerId === this.handlerId) {\n            return;\n        }\n        this.handlerId = newHandlerId;\n        this.reconnect();\n    }\n    get dropTargetOptions() {\n        return this.dropTargetOptionsInternal;\n    }\n    set dropTargetOptions(options) {\n        this.dropTargetOptionsInternal = options;\n    }\n    didHandlerIdChange() {\n        return this.lastConnectedHandlerId !== this.handlerId;\n    }\n    didDropTargetChange() {\n        return this.lastConnectedDropTarget !== this.dropTarget;\n    }\n    didOptionsChange() {\n        return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);\n    }\n    disconnectDropTarget() {\n        if (this.unsubscribeDropTarget) {\n            this.unsubscribeDropTarget();\n            this.unsubscribeDropTarget = undefined;\n        }\n    }\n    get dropTarget() {\n        return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;\n    }\n    clearDropTarget() {\n        this.dropTargetRef = null;\n        this.dropTargetNode = null;\n    }\n    constructor(backend){\n        this.hooks = wrapConnectorHooks({\n            dropTarget: (node, options)=>{\n                this.clearDropTarget();\n                this.dropTargetOptions = options;\n                if (isRef(node)) {\n                    this.dropTargetRef = node;\n                } else {\n                    this.dropTargetNode = node;\n                }\n                this.reconnect();\n            }\n        });\n        this.handlerId = null;\n        // The drop target may either be attached via ref or connect function\n        this.dropTargetRef = null;\n        this.dropTargetOptionsInternal = null;\n        this.lastConnectedHandlerId = null;\n        this.lastConnectedDropTarget = null;\n        this.lastConnectedDropTargetOptions = null;\n        this.backend = backend;\n    }\n}\n\n//# sourceMappingURL=TargetConnector.mjs.map","import { useMemo } from 'react';\nexport function useConnectDropTarget(connector) {\n    return useMemo(()=>connector.hooks.dropTarget()\n    , [\n        connector\n    ]);\n}\n\n//# sourceMappingURL=connectors.mjs.map","import { useRegisteredDropTarget } from './useRegisteredDropTarget.mjs';\nimport { useOptionalFactory } from '../useOptionalFactory.mjs';\nimport { useDropTargetMonitor } from './useDropTargetMonitor.mjs';\nimport { useDropTargetConnector } from './useDropTargetConnector.mjs';\nimport { useCollectedProps } from '../useCollectedProps.mjs';\nimport { useConnectDropTarget } from './connectors.mjs';\n/**\n * useDropTarget Hook\n * @param spec The drop target specification (object or function, function preferred)\n * @param deps The memoization deps array to use when evaluating spec changes\n */ export function useDrop(specArg, deps) {\n    const spec = useOptionalFactory(specArg, deps);\n    const monitor = useDropTargetMonitor();\n    const connector = useDropTargetConnector(spec.options);\n    useRegisteredDropTarget(spec, monitor, connector);\n    return [\n        useCollectedProps(spec.collect, monitor, connector),\n        useConnectDropTarget(connector), \n    ];\n}\n\n//# sourceMappingURL=useDrop.mjs.map","import { useMemo } from 'react';\nimport { DropTargetMonitorImpl } from '../../internals/index.mjs';\nimport { useDragDropManager } from '../useDragDropManager.mjs';\nexport function useDropTargetMonitor() {\n    const manager = useDragDropManager();\n    return useMemo(()=>new DropTargetMonitorImpl(manager)\n    , [\n        manager\n    ]);\n}\n\n//# sourceMappingURL=useDropTargetMonitor.mjs.map","import { useMemo } from 'react';\nimport { TargetConnector } from '../../internals/index.mjs';\nimport { useDragDropManager } from '../useDragDropManager.mjs';\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect.mjs';\nexport function useDropTargetConnector(options) {\n    const manager = useDragDropManager();\n    const connector = useMemo(()=>new TargetConnector(manager.getBackend())\n    , [\n        manager\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        connector.dropTargetOptions = options || null;\n        connector.reconnect();\n        return ()=>connector.disconnectDropTarget()\n        ;\n    }, [\n        options\n    ]);\n    return connector;\n}\n\n//# sourceMappingURL=useDropTargetConnector.mjs.map","import { useLayoutEffect, useEffect } from 'react';\n// suppress the useLayoutEffect warning on server side.\nexport const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\n//# sourceMappingURL=useIsomorphicLayoutEffect.mjs.map","import { useMemo } from 'react';\nexport function useOptionalFactory(arg, deps) {\n    const memoDeps = [\n        ...deps || []\n    ];\n    if (deps == null && typeof arg !== 'function') {\n        memoDeps.push(arg);\n    }\n    return useMemo(()=>{\n        return typeof arg === 'function' ? arg() : arg;\n    }, memoDeps);\n}\n\n//# sourceMappingURL=useOptionalFactory.mjs.map","export function isRef(obj) {\n    return(// eslint-disable-next-line no-prototype-builtins\n    obj !== null && typeof obj === 'object' && Object.prototype.hasOwnProperty.call(obj, 'current'));\n}\n\n//# sourceMappingURL=isRef.mjs.map","export function registerTarget(type, target, manager) {\n    const registry = manager.getRegistry();\n    const targetId = registry.addTarget(type, target);\n    return [\n        targetId,\n        ()=>registry.removeTarget(targetId)\n    ];\n}\nexport function registerSource(type, source, manager) {\n    const registry = manager.getRegistry();\n    const sourceId = registry.addSource(type, source);\n    return [\n        sourceId,\n        ()=>registry.removeSource(sourceId)\n    ];\n}\n\n//# sourceMappingURL=registration.mjs.map","import { invariant } from '@react-dnd/invariant';\nimport { cloneElement, isValidElement } from 'react';\nfunction throwIfCompositeComponentElement(element) {\n    // Custom components can no longer be wrapped directly in React DnD 2.0\n    // so that we don't need to depend on findDOMNode() from react-dom.\n    if (typeof element.type === 'string') {\n        return;\n    }\n    const displayName = element.type.displayName || element.type.name || 'the component';\n    throw new Error('Only native element nodes can now be passed to React DnD connectors.' + `You can either wrap ${displayName} into a <div>, or turn it into a ` + 'drag source or a drop target itself.');\n}\nfunction wrapHookToRecognizeElement(hook) {\n    return (elementOrNode = null, options = null)=>{\n        // When passed a node, call the hook straight away.\n        if (!isValidElement(elementOrNode)) {\n            const node = elementOrNode;\n            hook(node, options);\n            // return the node so it can be chained (e.g. when within callback refs\n            // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n            return node;\n        }\n        // If passed a ReactElement, clone it and attach this function as a ref.\n        // This helps us achieve a neat API where user doesn't even know that refs\n        // are being used under the hood.\n        const element = elementOrNode;\n        throwIfCompositeComponentElement(element);\n        // When no options are passed, use the hook directly\n        const ref = options ? (node)=>hook(node, options)\n         : hook;\n        return cloneWithRef(element, ref);\n    };\n}\nexport function wrapConnectorHooks(hooks) {\n    const wrappedHooks = {};\n    Object.keys(hooks).forEach((key)=>{\n        const hook = hooks[key];\n        // ref objects should be passed straight through without wrapping\n        if (key.endsWith('Ref')) {\n            wrappedHooks[key] = hooks[key];\n        } else {\n            const wrappedHook = wrapHookToRecognizeElement(hook);\n            wrappedHooks[key] = ()=>wrappedHook\n            ;\n        }\n    });\n    return wrappedHooks;\n}\nfunction setRef(ref, node) {\n    if (typeof ref === 'function') {\n        ref(node);\n    } else {\n        ref.current = node;\n    }\n}\nfunction cloneWithRef(element, newRef) {\n    const previousRef = element.ref;\n    invariant(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs');\n    if (!previousRef) {\n        // When there is no ref on the element, use the new ref directly\n        return cloneElement(element, {\n            ref: newRef\n        });\n    } else {\n        return cloneElement(element, {\n            ref: (node)=>{\n                setRef(previousRef, node);\n                setRef(newRef, node);\n            }\n        });\n    }\n}\n\n//# sourceMappingURL=wrapConnectorHooks.mjs.map"],"names":["invariant","condition","format","args","process","undefined","Error","error","argIndex","replace","name","framesToPop","shallowEqual","objA","objB","compare","compareContext","compareResult","call","keysA","Object","keys","keysB","length","bHasOwnProperty","prototype","hasOwnProperty","bind","idx","key","valueA","valueB","DndContext","createContext","dragDropManager","useMonitorOutput","monitor","collect","onCollect","collected","updateCollected","onUpdate","setCollected","useState","useCallback","nextValue","useIsomorphicLayoutEffect","useCollector","handlerId","getHandlerId","subscribeToStateChange","handlerIds","useCollectedProps","collector","connector","reconnect","useDragDropManager","useContext","DropTargetImpl","canDrop","spec","this","getItem","hover","drop","constructor","useRegisteredDropTarget","manager","dropTarget","useMemo","useEffect","useDropTarget","accept","Array","isArray","useAccept","unregister","receiveHandlerId","map","a","toString","join","isCallingCanDrop","DropTargetMonitorImpl","targetId","listener","options","internalMonitor","canDropOnTarget","isOver","isOverTarget","getItemType","getDropResult","didDrop","getInitialClientOffset","getInitialSourceClientOffset","getSourceClientOffset","getClientOffset","getDifferenceFromInitialOffset","getMonitor","TargetConnector","connectTarget","didChange","didHandlerIdChange","didDropTargetChange","didOptionsChange","disconnectDropTarget","lastConnectedHandlerId","lastConnectedDropTarget","lastConnectedDropTargetOptions","dropTargetOptions","unsubscribeDropTarget","backend","connectDropTarget","newHandlerId","dropTargetOptionsInternal","dropTargetNode","dropTargetRef","current","clearDropTarget","hooks","wrapConnectorHooks","node","isRef","useConnectDropTarget","useDrop","specArg","deps","useOptionalFactory","useDropTargetMonitor","getBackend","useDropTargetConnector","window","useLayoutEffect","arg","memoDeps","push","obj","registerTarget","type","target","registry","getRegistry","addTarget","removeTarget","registerSource","source","sourceId","addSource","removeSource","wrapHookToRecognizeElement","hook","elementOrNode","isValidElement","element","displayName","throwIfCompositeComponentElement","newRef","previousRef","ref","cloneElement","setRef","cloneWithRef","wrappedHooks","forEach","endsWith","wrappedHook"],"sourceRoot":""}