{"version":3,"file":"static/chunks/6384.78a3eb85ce5b85cd.js","mappings":"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","sources":["webpack://_N_E/../node_modules/invariant/browser.js","webpack://_N_E/../node_modules/lodash/_baseForOwn.js","webpack://_N_E/../node_modules/lodash/mapValues.js","webpack://_N_E/../node_modules/uniforms/esm/connectField.js","webpack://_N_E/../node_modules/uniforms/esm/context.js","webpack://_N_E/../node_modules/uniforms/esm/joinName.js","webpack://_N_E/../node_modules/uniforms/esm/useField.js","webpack://_N_E/../node_modules/uniforms/esm/useForm.js","webpack://_N_E/../packages/react-admin/lib-es/RaSelectReferenceInputField.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var baseAssignValue = require('./_baseAssignValue'),\n    baseForOwn = require('./_baseForOwn'),\n    baseIteratee = require('./_baseIteratee');\n\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */\nfunction mapValues(object, iteratee) {\n  var result = {};\n  iteratee = baseIteratee(iteratee, 3);\n\n  baseForOwn(object, function(value, key, object) {\n    baseAssignValue(result, key, iteratee(value, key, object));\n  });\n  return result;\n}\n\nmodule.exports = mapValues;\n","import mapValues from 'lodash/mapValues';\nimport React from 'react';\nimport { context as contextReference } from './context';\nimport { useField } from './useField';\nfunction getNextContext(context, props, options) {\n    // Leaf components by definition do not affect the context. `AutoField` will\n    // skip most of them anyway, but if rendered directly we have to do it here.\n    // An example in the core theme are the `List*Field`s.\n    if ((options === null || options === void 0 ? void 0 : options.kind) === 'leaf') {\n        return context;\n    }\n    const changesName = props.name !== '';\n    const changesState = Object.keys(context.state).some(key => {\n        const next = props[key];\n        return next !== null && next !== undefined;\n    });\n    // There are no other ways of affecting the context.\n    if (!changesName && !changesState) {\n        return context;\n    }\n    const nextContext = Object.assign({}, context);\n    if (changesName) {\n        nextContext.name = nextContext.name.concat(props.name);\n    }\n    if (changesState) {\n        nextContext.state = mapValues(nextContext.state, (prev, key) => {\n            const next = props[key];\n            return next !== null && next !== undefined ? !!next : prev;\n        });\n    }\n    return nextContext;\n}\nexport function connectField(Component, options) {\n    function Field(props) {\n        const [fieldProps, context] = useField(props.name, props, options);\n        const nextContext = getNextContext(context, props, options);\n        const body = React.createElement(Component, Object.assign({}, props, fieldProps));\n        // If the context has not changed, then don't render the `Provider`. It's\n        // possible that it will change at some point, but it's extremely rare, as\n        // either `name` or one of the \"state props\" has to change.\n        if (context === nextContext) {\n            return body;\n        }\n        return React.createElement(contextReference.Provider, { children: body, value: nextContext });\n    }\n    Field.displayName = `${Component.displayName || Component.name}Field`;\n    return Object.assign(Field, { Component, options });\n}\n","import { createContext } from 'react';\nexport const context = createContext(null);\n","const escapeMatch = /[.[\\]]/;\nconst escapeRegex = /\"/g;\n/** @internal */\nfunction escape(string) {\n    return string === '' || escapeMatch.test(string)\n        ? `[\"${string.replace(escapeRegex, '\\\\\"')}\"]`\n        : string;\n}\n/** @internal */\nfunction escapeToJoin(string, index) {\n    const escaped = escape(string);\n    return escaped === string ? (index ? `.${string}` : string) : escaped;\n}\nconst unescapeMatch = /^\\[\"(.*)\"]$/;\nconst unescapeRegex = /\\\\\"/g;\n/** @internal */\nfunction unescape(string) {\n    const match = unescapeMatch.exec(string);\n    return match ? match[1].replace(unescapeRegex, '\"') : string;\n}\n// This regular expression splits the string into three parts:\n//   `prefix` is a dotted name, e.g., `object.nested.2.field` at the\n//            front (hence prefix). It covers most standard usecases.\n//   `subscript` is a `[\"...\"]` subscript after the prefix. The content\n//               within should be escaped by the user, e.g., `[\"\\\\\"\"]`.\n//   `rest` is anything following the subscript. The leading dot (`.`)\n//          is stripped (`.a` -> `a`) if there is one. It is empty if\n//          `subscript` is empty.\n//\n// All three parts can be empty!\nconst nameRegex = /^([^.[\\]]*(?:\\.[^.[\\]]+)*)(?:\\.?(\\[\"(?:(?:[^\"]|\\\\\")*?[^\\\\])?\"])\\.?(.*))?$/;\n// eslint-disable-next-line complexity -- The complexity of it _is_ high.\nfunction joinNameImpl(...parts) {\n    // If the first argument is `null`, then we return an escaped array of parts.\n    // Otherwise, an escaped string is returned. As we may modify `parts` later,\n    // this has to be checked now.\n    const returnAsParts = parts[0] === null;\n    // Result parts (not escaped).\n    const name = [];\n    // This cannot be transformed into a `.forEach` loop and the length of it\n    // can not be memoized, as we modify `parts` as we go for performance reasons.\n    for (let index = 0; index !== parts.length; ++index) {\n        const part = parts[index];\n        // All falsy values except `0` are ignored.\n        if (part || part === 0) {\n            if (typeof part === 'string') {\n                // Strings are matched against the regular expression that split it into\n                // three parts (all can be empty):\n                //   `prefix` is a dotted name, e.g., `object.nested.2.field` at the\n                //            front (hence prefix). It covers most standard usecases.\n                //   `subscript` is a `[\"...\"]` subscript after the prefix. The content\n                //               within should be escaped by the user, e.g., `[\"\\\\\"\"]`.\n                //   `rest` is anything following the subscript. The leading dot (`.`)\n                //          is stripped (`.a` -> `a`) if there is one. It is empty if\n                //          `subscript` is empty.\n                const match = nameRegex.exec(part);\n                if (match) {\n                    const [, prefix, subscript, rest] = match;\n                    if (prefix) {\n                        // We could always `.split` the `prefix`, but it results in a severe\n                        // performance hit.\n                        if (prefix.includes('.')) {\n                            name.push(...prefix.split('.'));\n                        }\n                        else {\n                            name.push(prefix);\n                        }\n                    }\n                    if (subscript) {\n                        // We could adjust the `nameRegex` to skip brackets and `unescape`\n                        // to skip this check, but then every other call (e.g., a one in the\n                        // bridge) would have to know that. The performance is not affected\n                        // much by it anyway.\n                        name.push(unescape(subscript));\n                        // The `rest` is inlined in place as it is a single string.\n                        if (rest) {\n                            parts[index--] = rest;\n                        }\n                    }\n                }\n                else {\n                    // If a string is not matching the pattern, we leave it as it is. We\n                    // may want to raise a warning here as it should not happen. Most\n                    // likely it is something that should have been escaped (e.g., `[`).\n                    name.push(part);\n                }\n            }\n            else if (Array.isArray(part)) {\n                // Arrays are flattened in place but only if needed, i.e., they are not\n                // empty. We calculate the length of the overlapping parts to reuse the\n                // `parts` array as much as possible:\n                // [[], ...]              -> [[], ...]       // No change.\n                // [['a'], ...]           -> ['a', ...]      // Inline in place.\n                // [['a', 'b'], ...]      -> ['a', 'b', ...] // Inline with extension.\n                // ['a', ['b'], ...]      -> ['a', 'b', ...] // Inline in place.\n                // ['a', ['b', 'c'], ...] -> ['b', 'c', ...] // Inline with overlap.\n                if (part.length) {\n                    const length = Math.min(index + 1, part.length);\n                    index -= length;\n                    parts.splice(index + 1, length, ...part);\n                }\n            }\n            else {\n                // Other values -- most likely numbers and `true` -- are stringified.\n                name.push('' + part);\n            }\n        }\n    }\n    // We cannot escape the parts earlier as `escapeToJoin` depends on the index.\n    return returnAsParts ? name.map(escape) : name.map(escapeToJoin).join('');\n}\nexport const joinName = Object.assign(joinNameImpl, { escape, unescape });\n","import get from 'lodash/get';\nimport mapValues from 'lodash/mapValues';\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { joinName } from './joinName';\nimport { useForm } from './useForm';\nfunction propagate(prop, schema, state, fallback) {\n    const forcedFallbackInProp = prop === true || prop === undefined;\n    const forcedFallbackInSchema = schema === true || schema === undefined;\n    const schemaValue = forcedFallbackInSchema ? fallback : schema;\n    const value = prop === '' ||\n        prop === false ||\n        prop === null ||\n        (forcedFallbackInProp && (forcedFallbackInSchema || !state))\n        ? ''\n        : forcedFallbackInProp\n            ? schemaValue\n            : prop;\n    return [value, schemaValue];\n}\nexport function useField(fieldName, props, options) {\n    var _a;\n    const context = useForm();\n    const name = joinName((options === null || options === void 0 ? void 0 : options.absoluteName) ? '' : context.name, fieldName);\n    const field = context.schema.getField(name);\n    const usesInitialValue = (options === null || options === void 0 ? void 0 : options.initialValue) !== false;\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const onChangeCalled = usesInitialValue ? useRef(false) : { current: false };\n    const state = mapValues(context.state, (prev, key) => {\n        const next = props[key];\n        return next !== null && next !== undefined ? !!next : prev;\n    });\n    const changed = !!get(context.changedMap, name);\n    const error = context.schema.getError(name, context.error);\n    const errorMessage = context.schema.getErrorMessage(name, context.error);\n    const fieldType = context.schema.getType(name);\n    const fields = context.schema.getSubfields(name);\n    const schemaProps = context.schema.getProps(name, Object.assign(Object.assign({}, state), props));\n    const [label, labelFallback] = propagate(props.label, schemaProps.label, state.label, '');\n    const [placeholder] = propagate(props.placeholder, schemaProps.placeholder, state.placeholder, label || labelFallback);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const id = useMemo(() => context.randomId(), []);\n    const onChange = useCallback((value, key = name) => {\n        onChangeCalled.current = true;\n        context.onChange(key, value);\n    }, \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [context.onChange, name]);\n    const valueFromModel = get(context.model, name);\n    let initialValue;\n    let value = (_a = props.value) !== null && _a !== void 0 ? _a : valueFromModel;\n    if (usesInitialValue) {\n        if (!onChangeCalled.current) {\n            if (value === undefined) {\n                value = context.schema.getInitialValue(name, props);\n                initialValue = value;\n            }\n            else if (props.value !== undefined && props.value !== valueFromModel) {\n                initialValue = props.value;\n            }\n        }\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useEffect(() => {\n            var _a;\n            const required = (_a = props.required) !== null && _a !== void 0 ? _a : schemaProps.required;\n            if (required && initialValue !== undefined) {\n                onChange(initialValue);\n            }\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, []);\n    }\n    const fieldProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ id }, state), { changed,\n        error,\n        errorMessage,\n        field,\n        fieldType,\n        fields,\n        onChange,\n        value }), schemaProps), props), { label,\n        name, \n        // TODO: Should we assert `typeof placeholder === 'string'`?\n        placeholder: placeholder });\n    return [fieldProps, context];\n}\n","import invariant from 'invariant';\nimport { useContext } from 'react';\nimport { context as contextReference } from './context';\nexport function useForm() {\n    const context = useContext(contextReference);\n    invariant(context !== null, 'useForm must be used within a form.');\n    return context;\n}\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { ReferenceInput, SelectInput } from 'react-admin';\nimport { connectField } from 'uniforms';\nimport React from 'react';\n/**\n * RaSelectReferenceInputField can be used in an autoform to\n */\nvar RaSelectReferenceInputField = connectField(function (_a) {\n    var _b = _a.allowEmpty, allowEmpty = _b === void 0 ? true : _b, _c = _a.value, value = _c === void 0 ? null : _c, onChange = _a.onChange, optionText = _a.optionText, optionValue = _a.optionValue, label = _a.label, props = __rest(_a, [\"allowEmpty\", \"value\", \"onChange\", \"optionText\", \"optionValue\", \"label\"]);\n    return (React.createElement(ReferenceInput, { label: label, reference: props.reference, perPage: props.perPage, allowEmpty: allowEmpty, meta: {}, input: {\n            value: value,\n            onChange: function (e) {\n                onChange(e.target.value);\n            },\n        }, source: null },\n        React.createElement(SelectInput, { optionText: optionText || 'id', emptyValue: null, optionValue: optionValue || 'id', options: { value: value } })));\n});\nexport default RaSelectReferenceInputField;\n//# sourceMappingURL=RaSelectReferenceInputField.js.map"],"names":["module","exports","condition","format","a","b","c","d","e","f","error","undefined","Error","args","argIndex","replace","name","framesToPop","baseFor","keys","object","iteratee","baseAssignValue","baseForOwn","baseIteratee","result","value","key","connectField","Component","options","Field","props","fieldProps","context","nextContext","kind","changesName","changesState","Object","state","some","next","assign","concat","prev","getNextContext","body","children","displayName","createContext","escapeMatch","escapeRegex","escape","string","test","escapeToJoin","index","escaped","unescapeMatch","unescapeRegex","unescape","match","exec","nameRegex","joinName","parts","returnAsParts","length","part","prefix","subscript","rest","includes","push","split","Array","isArray","Math","min","splice","map","join","propagate","prop","schema","fallback","forcedFallbackInProp","forcedFallbackInSchema","schemaValue","useField","fieldName","_a","absoluteName","field","getField","usesInitialValue","initialValue","onChangeCalled","useRef","current","changed","changedMap","getError","errorMessage","getErrorMessage","fieldType","getType","fields","getSubfields","schemaProps","getProps","label","labelFallback","placeholder","id","useMemo","randomId","onChange","useCallback","valueFromModel","model","getInitialValue","useEffect","required","useForm","useContext","__rest","s","t","p","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","propertyIsEnumerable","RaSelectReferenceInputField","_b","allowEmpty","_c","optionText","optionValue","reference","perPage","meta","input","target","source","emptyValue"],"sourceRoot":""}